{"version":3,"sources":["components/auth/authSettings.js","components/auth/Login.js","components/auth/Register.js","components/paths/PathsProvider2.js","components/routes/RouteProvider.js","modules/RouteStreetNames.js","components/routes/TrafficProvider.js","components/routes/RouteCard.js","components/routes/RouteForms.js","components/routes/RoutePage.js","components/users/UserProvider.js","components/users/UserEditForm.js","components/Checkpoint.js","reportWebVitals.js","index.js"],"names":["authApi","userStorageKey","Login","useState","email","loginUser","setLoginUser","existDialog","setExistDialog","history","useHistory","className","open","onClick","e","onSubmit","preventDefault","fetch","then","res","json","user","length","exists","sessionStorage","setItem","id","push","htmlFor","type","placeholder","required","autoFocus","value","onChange","event","newUser","target","to","Register","firstName","lastName","registerUser","setRegisterUser","conflictDialog","setConflictDialog","handleInputChange","style","textAlign","userExists","method","headers","body","JSON","stringify","createdUser","hasOwnProperty","name","PathsContext","createContext","PathsProvider2","props","useContext","RouteContext","getLatLong","getRoutePath","newRoute","useEffect","origin","arrayOfPromises","finalLatLong","latLongStreetObjects","finalArrayOfStreetNames","destination","arrayOfStreetNames","map","streetName","Promise","all","optionsArray","forEach","options","splitOrigin","split","splitDestination","splice","originCity","destinationCity","optionsStreetNamesString","items","itemObj","title","join","toLowerCase","includes","find","item","a","Object","values","position","i","newRoutePath","latLong","routeId","order","postRoutePath","timer","destructuredLat","destructuredLong","ms","setTimeout","routePathObj","Provider","getPathByRouteId","routeObj","children","RouteProvider","routes","setRoutes","setNewRoute","address","process","REACT_APP_API","getDirections","originObj","destinationObj","addNewRoute","getRoutes","routesArray","getRouteById","routeObjId","deleteRoute","updateRoute","userId","originLatLong","destinationLatLong","directions","route","originString","filteredStreetNames","sections","turnByTurnActions","filter","undefined","nextRoad","streetNames","actionObj","number","finalStreetNamesWithoutDuplicates","Set","finalSpecificStreetNames","originState","getRouteStreetNames","TrafficContext","TrafficProvider","incidents","setIncidents","getTrafficIncidentData","latLongString","replace","ok","console","log","getIncidentAndLocation","routePathArray","streetNameObj","RouteCard","incidentsToPost","setIncidentsToPost","eventId","setEventId","messageToPost","setMessageToPost","editClicked","setEditClicked","routeToEdit","setRouteToEdit","isComplete","setIsComplete","visualPath","setVisualPath","TRAFFICITEMS","TRAFFICITEM","incident","Card","Text","TRAFFICITEMDESCRIPTION","content","Math","random","addDiv","handleChangeInput","newRouteToEdit","Body","Button","handleViewPathClick","Title","parseInt","handleCheckTrafficClick","ButtonGroup","aria-label","disabled","RouteForms","setRoute","originStreet","originCSZ","destinationStreet","destinationCSZ","setOptions","newOptions","currentUserId","getItem","Form","Control","RoutePage","userRoutes","setUserRoutes","filteredRoutes","removeItem","UserContext","UserProvider","userObject","setUserObject","getLoggedInUserObject","updateUser","userObj","UserEditForm","userToEdit","setUserToEdit","updatedUserToEdit","Checkpoint","render","exact","path","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.cbe6b4fa.chunk.js","sourcesContent":["// If your json-server API URL or endpoint is different, please change it below!\nexport const authApi = {\n  localApiBaseUrl: \"https://checkpoint--api.herokuapp.com\",\n  endpoint: \"users\"\n}\n\n// The user id is saved under the key app_user_id in session Storage. Change below if needed!\nexport const userStorageKey = \"app_user_id\"\n\n\n\n\n","import React, { useState } from \"react\"\nimport { Link, useHistory } from \"react-router-dom\";\nimport { authApi, userStorageKey } from \"./authSettings\"\n\nexport const Login = () => {\n    const [loginUser, setLoginUser] = useState({ email: \"\" })\n    const [existDialog, setExistDialog] = useState(false)\n\n    const history = useHistory()\n\n    const handleInputChange = (event) => {\n        const newUser = { ...loginUser }\n        newUser[event.target.id] = event.target.value\n        setLoginUser(newUser)\n    }\n\n\n    const existingUserCheck = () => {\n        return fetch(`${authApi.localApiBaseUrl}/${authApi.endpoint}?email=${loginUser.email}`)\n            .then(res => res.json())\n            .then(user => user.length ? user[0] : false)\n    }\n\n    const handleLogin = (e) => {\n        e.preventDefault()\n\n        existingUserCheck()\n            .then(exists => {\n                if (exists) {\n                    sessionStorage.setItem(userStorageKey, exists.id)\n                    history.push(\"/\")\n                } else {\n                    setExistDialog(true)\n                }\n            })\n    }\n\n    return (\n        <main className=\"container--login\">\n            <dialog className=\"dialog dialog--auth\" open={existDialog}>\n                <div>User does not exist</div>\n                <button className=\"button--close\" onClick={e => setExistDialog(false)}>Close</button>\n            </dialog>\n            <section>\n                <form className=\"form--login\" onSubmit={handleLogin}>\n                    <h1>Checkpoint</h1>\n                    <h2>Please sign in</h2>\n                    <fieldset>\n                        <label htmlFor=\"inputEmail\"> Email address </label>\n                        <input type=\"email\"\n                            id=\"email\"\n                            className=\"form-control\"\n                            placeholder=\"Email address\"\n                            required autoFocus\n                            value={loginUser.email}\n                            onChange={handleInputChange} />\n                    </fieldset>\n                    <fieldset>\n                        <button type=\"submit\">\n                            Sign in\n                        </button>\n                    </fieldset>\n                </form>\n            </section>\n            <section className=\"link--register\">\n                <Link to=\"/register\">Register for an account</Link>\n            </section>\n        </main>\n    )\n}\n\n","import React, { useState } from \"react\"\nimport { useHistory } from \"react-router-dom\"\nimport { authApi, userStorageKey } from \"./authSettings\"\n\nexport const Register = () => {\n\n    const [registerUser, setRegisterUser] = useState({ firstName: \"\", lastName: \"\", email: \"\" })\n    const [conflictDialog, setConflictDialog] = useState(false)\n\n    const history = useHistory()\n\n    const handleInputChange = (event) => {\n        const newUser = { ...registerUser }\n        newUser[event.target.id] = event.target.value\n        setRegisterUser(newUser)\n    }\n\n    const existingUserCheck = () => {\n        \n        return fetch(`${authApi.localApiBaseUrl}/${authApi.endpoint}?email=${registerUser.email}`)\n            .then(res => res.json())\n            .then(user => !!user.length)\n    }\n\n    const handleRegister = (e) => {\n        e.preventDefault()\n\n        existingUserCheck()\n            .then((userExists) => {\n                if (!userExists) {\n                    fetch(`${authApi.localApiBaseUrl}/${authApi.endpoint}`, {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            email: registerUser.email,\n                            firstName: registerUser.firstName,\n                            lastName: registerUser.lastName\n                        })\n                    })\n                        .then(res => res.json())\n                        .then(createdUser => {\n                            if (createdUser.hasOwnProperty(\"id\")) {\n                                sessionStorage.setItem(userStorageKey, createdUser.id)\n                                history.push(\"/\")\n                            }\n                        })\n                }\n                else {\n                    setConflictDialog(true)\n                }\n            })\n\n    }\n\n    return (\n        <main style={{ textAlign: \"center\" }}>\n\n            <dialog className=\"dialog dialog--password\" open={conflictDialog}>\n                <div>Account with that email address already exists</div>\n                <button className=\"button--close\" onClick={e => setConflictDialog(false)}>Close</button>\n            </dialog>\n\n            <form className=\"form--login\" onSubmit={handleRegister}>\n                <h1 className=\"h3 mb-3 font-weight-normal\">Please Register for Application Name</h1>\n                <fieldset>\n                    <label htmlFor=\"firstName\"> First Name </label>\n                    <input type=\"text\" name=\"firstName\" id=\"firstName\" className=\"form-control\" placeholder=\"First name\" required autoFocus value={registerUser.firstName} onChange={handleInputChange} />\n                </fieldset>\n                <fieldset>\n                    <label htmlFor=\"lastName\"> Last Name </label>\n                    <input type=\"text\" name=\"lastName\" id=\"lastName\" className=\"form-control\" placeholder=\"Last name\" required value={registerUser.lastName} onChange={handleInputChange} />\n                </fieldset>\n                <fieldset>\n                    <label htmlFor=\"inputEmail\"> Email address </label>\n                    <input type=\"email\" name=\"email\" id=\"email\" className=\"form-control\" placeholder=\"Email address\" required value={registerUser.email} onChange={handleInputChange} />\n                </fieldset>\n                <fieldset>\n                    <button type=\"submit\"> Sign in </button>\n                </fieldset>\n            </form>\n        </main>\n    )\n}\n\n","import React, { createContext, useContext, useEffect } from \"react\"\nimport { RouteContext } from \"../routes/RouteProvider\"\n\nexport const PathsContext = createContext()\n\nexport const PathsProvider2 = (props) => {\n    const { getLatLong, getRoutePath, newRoute } = useContext(RouteContext)\n    useEffect(() => {\n\n        if (newRoute.origin) {\n            let arrayOfPromises = []\n            let finalLatLong = []\n            let latLongStreetObjects = []\n            let finalArrayOfStreetNames = []\n            let origin = newRoute.origin\n            let destination = newRoute.destination\n            getRoutePath(newRoute.origin, newRoute.destination)\n                .then(arrayOfStreetNames => {\n                    arrayOfPromises = arrayOfStreetNames.map(streetName => {\n                        // Runs each street name string through the geocoder API to get the lat/long\n                        return getLatLong(streetName)\n                    })\n                    // Waits for arrayOfPromises to return and then returns that result (the lat/long of each street name)\n                    return Promise.all(arrayOfPromises)\n                })\n                .then(optionsArray => {\n                    // optionsArray is an array of objects where each object contains an array of objects representing a potential street name\n                    optionsArray.forEach(options => {\n                        // Splices the origin and destination string into an array of strings\n                        const splitOrigin = origin.split(\" \")\n                        const splitDestination = destination.split(\" \")\n\n                        // returns an array of a single string representing city name\n                        const [originCity] = splitOrigin.splice(-3, 1)\n                        const [destinationCity] = splitDestination.splice(-3, 1)\n\n                        // Returns an array of just street name strings, includes steet address, city, state, zip\n                        const optionsStreetNames = options.items.map(itemObj => itemObj.title)\n\n                        // Joins entire array of street names to create 1 single string containing all potential street names\n                        const optionsStreetNamesString = optionsStreetNames.join(\"\")\n\n                        // Checks to see if the joined string of all street names contains origin or destination city\n                        if (optionsStreetNamesString.toLowerCase().includes(`${originCity.toLowerCase()}`) || optionsStreetNamesString.toLowerCase().includes(`${destinationCity.toLowerCase()}`)) {\n                            // If true, push the first street name object that contains origin or destination city into latLongStreetObjects array\n                            latLongStreetObjects.push(options.items.find(item => item.title.toLowerCase().includes(`${originCity.toLowerCase()}`) || item.title.toLowerCase().includes(`${destinationCity.toLowerCase()}`)))\n                        } else {\n                            // If false, push an empty string (placeholder) into array\n                            latLongStreetObjects.push(\" \")\n                        }\n                    })\n                })\n                // Uses async/await so that the entire function runs and then awaits completion of specified function\n                .then(async () => {\n                    // Maps array of street name objects and pushes either the placeholder empty string or the lat/long into finalLatLong\n                    latLongStreetObjects.map(item => item === \" \" ? finalLatLong.push(\"\") : finalLatLong.push(Object.values(item.position)))\n\n                    // Runs everything inside the loop as many times as there are items in finalLatLong\n                    for (let i = 0; i < finalLatLong.length; i++) {\n                        // For placeholder strings, create path objects with empty string in place of latLong\n                        if (finalLatLong[i] === \"\") {\n                            const newRoutePath = {\n                                streetName: finalArrayOfStreetNames[i],\n                                latLong: finalLatLong[i],\n                                routeId: newRoute.id,\n                                order: i + 1\n                            }\n                            postRoutePath(newRoutePath)\n                            await timer(50)\n                        } else {\n                            // Where lat/long are not empty strings, use lat/long fot latlong\n                            const [destructuredLat, destructuredLong] = finalLatLong[i]\n                            const newRoutePath = {\n                                streetName: finalArrayOfStreetNames[i],\n                                latLong: destructuredLat + \", \" + destructuredLong,\n                                routeId: newRoute.id,\n                                order: i + 1\n                            }\n                            postRoutePath(newRoutePath)\n                            // Waits 50 ms between posts to prevent 429 error\n                            await timer(50)\n\n                        }\n                    }\n                })\n        }\n    }, [newRoute])\n\n    const timer = ms => new Promise(res => {\n        setTimeout(res, ms)\n    })\n\n    const postRoutePath = (routePathObj) => {\n        return fetch(`https://checkpoint--api.herokuapp.com/paths`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(routePathObj)\n        })\n    }\n\n    const getPathByRouteId = (routeObj) => {\n        return fetch(`https://checkpoint--api.herokuapp.com/paths?routeId=${routeObj.id}`)\n            .then(res => res.json())\n    }\n\n\n    return (\n        <PathsContext.Provider value={{\n            getPathByRouteId\n        }}>\n            {props.children}\n        </PathsContext.Provider>\n    )\n}","import React, { createContext, useEffect, useState } from \"react\"\nimport { getRouteStreetNames } from \"../../modules/RouteStreetNames\"\nimport { PathsProvider2 } from \"../paths/PathsProvider2\"\n\nexport const RouteContext = createContext()\n\nexport const RouteProvider = (props) => {\n    const [routes, setRoutes] = useState([])\n\n    const [newRoute, setNewRoute] = useState({})\n    const [routeToEditRoutePath, setRouteToEditRoutePath] = useState({})\n\n    //  Use HERE GeoCoding and Search API to convert street addresses to lat/long pair\n    const getLatLong = (address) => {\n        return fetch(`https://geocode.search.hereapi.com/v1/geocode?q=${address}&apiKey=${process.env.REACT_APP_API}`,)\n            .then(res => res.json())\n    }\n\n    // HERE Router API creates path from origin to destination\n    // Uses string interpolation to insert the values (lat/long) of the origin and destination objects\n    const getDirections = (originObj, destinationObj) => {\n        return fetch(`https://router.hereapi.com/v8/routes?transportMode=car&origin=${Object.values(originObj)}&destination=${Object.values(destinationObj)}&return=polyline,turnbyturnactions&apikey=${process.env.REACT_APP_API}`)\n            .then(res => res.json())\n    }\n\n    const addNewRoute = routeObj => {\n        return fetch(`https://checkpoint--api.herokuapp.com/routes`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(routeObj)\n        })\n        .then(res => res.json())\n        .then(setNewRoute)\n        .then(getRoutes)\n        .then(() => <PathsProvider2 />)\n\n    }\n    //set routes state variable equal to an array of all routes \n    const getRoutes = () => {\n        return fetch(\"https://checkpoint--api.herokuapp.com/routes\")\n            .then(res => res.json())\n            .then(routesArray => setRoutes(routesArray))\n    }\n\n    const getRouteById = (routeObjId) => {\n        return fetch(`https://checkpoint--api.herokuapp.com/routes/${routeObjId}?_embed=path`)\n            .then(res => res.json())\n    }\n\n    const deleteRoute = (routeId) => {\n        return fetch(`https://checkpoint--api.herokuapp.com/routes/${routeId}`, {\n            method: \"DELETE\"\n        })\n            .then(getRoutes)\n    }\n\n    const updateRoute = routeObj => {\n        return fetch(`https://checkpoint--api.herokuapp.com/routes/${routeObj.id}`, {\n            method: \"DELETE\"\n        })\n        .then(() => addNewRoute({\n            \"name\": routeObj.name,\n            \"origin\": routeObj.origin,\n            \"destination\": routeObj.destination,\n            \"userId\": routeObj.userId\n        }))\n    }\n\n    const getRoutePath = (origin, destination) => {\n        let originLatLong = {}\n        let destinationLatLong = {}\n        return getLatLong(origin)\n            .then(res => {\n                // res.items[0].position is an object containing lat and long as key value pairs\n                return originLatLong = res.items[0].position\n            })\n            .then(() => getLatLong(destination))\n            .then(res => {\n                // changes empty object variable equal to an object containing lat/long pair\n                return destinationLatLong = res.items[0].position\n            })\n            // Returns turn by turn directions from origin to destination\n            .then(() => getDirections(originLatLong, destinationLatLong))\n            // Returns an array of strings, where wach string is the next street a user should take \n            .then(directions => getRouteStreetNames(directions, origin))\n    }\n\n    return (\n        <RouteContext.Provider value={{\n            getLatLong, getDirections, addNewRoute, getRoutes, routes, getRouteById, deleteRoute, updateRoute, getRoutePath, newRoute\n\n        }}>\n            {props.children}\n        </RouteContext.Provider>\n    )\n}","// Returns an array of just street names that the user will follow during their drive\n\nexport const getRouteStreetNames = (route, originString) => {\n    // route.routes[0].sections[0].turnByTurnActions is an array of action objects like arrive, turn, continue\n    const turnByTurnDirections = route.routes[0].sections[0].turnByTurnActions\n\n    // Removes any action that doesn't contain a nextRoad value, because nextRoad conatins the street names that will be rendered\n    // Removes things like depart, arrive, continue\n    const filteredStreetNames = turnByTurnDirections.filter(name => name.nextRoad !== undefined)\n\n    // Stores only the key/value pairs that start with \"name\" or \"number\"\n    const streetNames = []\n    filteredStreetNames.forEach((actionObj) => actionObj.nextRoad.name ? streetNames.push(actionObj.nextRoad.name[0].value) : streetNames.push(actionObj.nextRoad.number[0].value))\n\n    // Creates a new set of street names where each street is only listed once; removes actions like \"continue\"\n    let finalStreetNamesWithoutDuplicates = [... new Set(streetNames)]\n\n    let finalSpecificStreetNames = []\n\n    if (originString) {\n\n        let splitOrigin = originString.split(\" \")\n        let [originState] = splitOrigin.splice(-2, 1)\n\n        finalStreetNamesWithoutDuplicates.forEach(name => {\n\n            finalSpecificStreetNames.push(name + \" \" + originState)\n        })\n        return finalSpecificStreetNames\n\n    } else {\n        return finalStreetNamesWithoutDuplicates\n    }\n    \n}","import React, { createContext, useContext, useState } from \"react\"\nimport { getRouteStreetNames } from \"../../modules/RouteStreetNames\"\nimport { PathsContext } from \"../paths/PathsProvider2\"\nimport { RouteContext } from \"./RouteProvider\"\n\nexport const TrafficContext = createContext()\n\nexport const TrafficProvider = (props) => {\n    // Declares state variable that can be set once traffice data is returned\n    const [incidents, setIncidents] = useState({})\n\n    // imports functions to be used in this component\n    const { getLatLong, getDirections, getRouteById } = useContext(RouteContext)\n\n    const { getPathByRouteId } = useContext(PathsContext)\n\n    const getIncidentAndLocation = (routeObj) => {\n        // Returns an array of path objects from database\n        return getPathByRouteId(routeObj)\n        .then(routePathArray => {\n            let latLongString = \"\"\n            // Iterates over each path object\n            // If latLong contains a lat/long add the lat/long to latLongString with a semicolon at the end\n            routePathArray.forEach(streetNameObj => streetNameObj.latLong !== \"\" ? latLongString = latLongString + streetNameObj.latLong + \";\" : latLongString)\n            return getTrafficIncidentData(latLongString)\n        })\n    }\n\n    const getTrafficIncidentData = (latLongString) => {\n        //Replaces spaces with empty strings\n        latLongString = latLongString.replace(/\\s+/g,'')\n\n        return fetch(`https://traffic.ls.hereapi.com/traffic/6.0/incidents.json?corridor=${latLongString}20&apiKey=${process.env.REACT_APP_API}`)\n            .then(res => {\n                if (res.ok) {\n                    // Tells me I got a good res\n                    console.log(\"got a good response\", res)\n                    return res.json()\n                } else {\n                    // Tells me I got a bad response\n                    console.log(\"you don't want that response\")\n\n                }\n            })\n            // sets incidents equal to data that was returned from fetch call\n            .then(res => {\n                setIncidents(res)\n            })\n    }\n\n    return (\n        <TrafficContext.Provider value={{\n            getIncidentAndLocation, incidents\n        }}>\n            {props.children}\n        </TrafficContext.Provider>\n    )\n\n}","import React, { useContext, useEffect, useState } from \"react\"\nimport { RouteContext } from \"./RouteProvider\"\nimport { TrafficContext } from \"./TrafficProvider\"\nimport Button from 'react-bootstrap/Button';\nimport Card from 'react-bootstrap/Card';\nimport { ButtonGroup } from 'react-bootstrap';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport \"./RouteCard.css\"\n\nexport const RouteCard = ({ routeObj }) => {\n    const { getIncidentAndLocation, incidents } = useContext(TrafficContext)\n\n    const { deleteRoute, getRouteById, updateRoute, getRoutePath } = useContext(RouteContext)\n\n    // state variable that will contain traffic incidents for a certain route\n    const [incidentsToPost, setIncidentsToPost] = useState([])\n    // Will store event.target.id after CheckTraffic is clicked\n    const [eventId, setEventId] = useState(0)\n    // Will store the message to be posted to the DOM on the appropriate card\n    const [messageToPost, setMessageToPost] = useState(<div></div>)\n    // Will be used to determine when to show buttons/input vs text\n    const [editClicked, setEditClicked] = useState(false)\n    // will be used to generate fields for input and handle changes to route\n    const [routeToEdit, setRouteToEdit] = useState({})\n    // Will be used to determine if all fields are complete\n    const [isComplete, setIsComplete] = useState(false)\n    // Will be used to cause re-render when array of street names is ready to be displayed on DOM\n    const [visualPath, setVisualPath] = useState([])\n\n    // TRAFFIC INFO\n\n    const handleCheckTrafficClick = (event) => {\n        // Gets incident data from API and sets incidents equal to the response object\n        getIncidentAndLocation(routeObj)\n            .then(() => {\n                // Sets eventId equal to event.target.id (id of the route where the button was clicked)\n                setEventId(parseInt(event.target.id))\n            })\n    }\n\n    const addDiv = () => {\n        // If eventId === the id of the object that was clicked\n        if (eventId === routeObj.id) {\n            // If IncidentsToPost is not undefined\n            if (incidentsToPost) {\n                // returns the content message for each incident\n                return (\n\n                    <div className=\"incidentMessage\"><h5>Traffic Incidents</h5> {incidentsToPost.map(incident => <Card.Text key={Math.random()}>{incident?.TRAFFICITEMDESCRIPTION[0].content}</Card.Text>)}</div>\n                )\n            } else {\n                // Returns all clear message if there are no incident objects in the array\n                return <Card.Text className=\"incidentMessage\">All clear! There are no incidents blocking your route</Card.Text>\n            }\n        }\n    }\n\n    useEffect(() => {\n        // When incidents variable changes, incidentsToPost is set equal to an array incident objects\n        setIncidentsToPost(incidents?.TRAFFICITEMS?.TRAFFICITEM)\n    }, [incidents])\n\n    useEffect(() => {\n        // When eventId set messageToPost equal to whatever is returned from the addDiv function\n        setMessageToPost(addDiv())\n    }, [eventId])\n\n    // DELETE\n\n    const handleDeleteClick = () => {\n        deleteRoute(routeObj.id)\n    }\n\n    // EDIT\n\n    const handleEditClick = () => {\n        // Get the route that needs to be edited\n        getRouteById(routeObj.id)\n            // set routeToEdit equal to the routeObj returned from the fetch call\n            .then(routeObj => setRouteToEdit(routeObj))\n    }\n\n    const handleChangeInput = (event) => {\n        // copy the route\n        const newRouteToEdit = { ...routeToEdit }\n        // Go to the key that matches the id of the input field being changed and reassign that key to whatever the user typed\n        newRouteToEdit[event.target.id] = event.target.value\n        // set routeToEdit equal to the changed route\n        setRouteToEdit(newRouteToEdit)\n    }\n\n    const handleViewPathClick = () => {\n        const newRouteToEdit = { ...routeToEdit }\n        // returns an array of strings; each string is a street name\n        getRoutePath(newRouteToEdit.origin, newRouteToEdit.destination)\n            \n            // set path equal to the array of street names so the user can view the street names on their route\n            .then(arrayOfStreetNames => setVisualPath(arrayOfStreetNames))\n    }\n\n    useEffect(() => {\n        // Checks to see if the route is at least 15 characters long; allows the user to save the route even if they don't make changes\n        if (routeToEdit.origin?.length > 15 && routeToEdit.destination?.length > 15) {\n            setIsComplete(true)\n        } else {\n            setIsComplete(false)\n        }\n    }, [routeToEdit])\n\n    const handleSaveClick = () => {\n        // Update the route in the database to match the changed route\n        updateRoute(routeToEdit)\n        // sets path back to an empty array ro remove the route path from the card\n        setVisualPath([])\n    }\n\n    return (\n        <Card className=\"savedRoutes__cards--routeCard\">\n            {/* Checks to see if editClicked is true */}\n            {editClicked ?\n                <>\n                    {/* IF TRUE, display inout field/textarea fields containing route name, origin, and destination that the user can change */}\n                    <div className=\"allEditFields\">\n                        <legend>Route Name</legend>\n                        <input id={\"name\"} type=\"text\" value={routeToEdit.name} onChange={event => handleChangeInput(event)}></input>\n                        <div className=\"legends\"><legend>Origin</legend><legend>Destination</legend></div>\n                        <div className=\"addressEditFields\">\n                            <textarea id={\"origin\"} type=\"text\" value={routeToEdit.origin} onChange={event => handleChangeInput(event)}></textarea>\n                            <textarea id={\"destination\"} type=\"text\" value={routeToEdit.destination} onChange={event => handleChangeInput(event)}></textarea>\n                        </div>\n                    </div>\n                    <Card.Body className=\"newRoute__path\">\n                        <h3>Your Route Path</h3>\n                        <p className=\"editedRoutePath\">{visualPath.join(\" to \")}</p>\n                        <Button className=\"route button\" onClick={() => handleViewPathClick()}>View Route Path</Button>\n                    </Card.Body>\n                </>\n                // IF FALSE, just display the route name as a header\n                : <Card.Title>{routeObj.name}</Card.Title>}\n\n            {editClicked ? \"\" :\n                <>\n                    {messageToPost}\n                    <Button className=\"traffic button\" id={routeObj.id} onClick={(event) => { handleCheckTrafficClick(event) }}>Check Traffic</Button>\n                </>\n            }\n\n            {/* Checks to see if editClicked is true */}\n            <ButtonGroup aria-label=\"First group\">\n                {editClicked ?\n                    // If true, display a Save button; disabled when any field is incomplete \n                    <Button className=\"save button\" disabled={!isComplete} onClick={() => { handleSaveClick(); setEditClicked(false) }} id={`${routeObj.id}`}>Save Changes</Button>\n                    // If false, display Edit button\n                    : <Button className=\"edit button\" onClick={() => { handleEditClick(); setEditClicked(true) }} id={`${routeObj.id}`}>Edit</Button>}\n                {/* Delete button */}\n                <Button className=\"delete button\" onClick={() => handleDeleteClick()}>Delete Route</Button>\n            </ButtonGroup>\n        </Card>\n    )\n}","// Reponsible for Route Form layout and state\nimport React, { useContext, useState, useEffect } from \"react\"\nimport { userStorageKey } from \"../auth/authSettings\"\nimport { RouteContext } from \"./RouteProvider\"\nimport Form from 'react-bootstrap/Form';\nimport { Card } from \"react-bootstrap\"\nimport \"./RouteForm.css\"\n\nexport const RouteForms = () => {\n    // imports functions to be used in this component\n    const { addNewRoute, getRoutePath } = useContext(RouteContext)\n    // Will be used to determine if all form fields are filled\n    const [isComplete, setIsComplete] = useState(false)\n    // Will be used to cause re-render when array of street names is ready to be displayed on DOM\n    const [visualPath, setVisualPath] = useState([\"Don't forget to check your path before clicking Save!\"])\n    // Will be used to save route to database\n    const [route, setRoute] = useState({})\n    // Because an input field can't be matched to a route key, this state variable will be used until all fields are ready to setRoute\n    const [options, setOptions] = useState({\n        name: \"\",\n        originStreet: \"\",\n        originCSZ: \"\",\n        destinationStreet: \"\",\n        destinationCSZ: \"\"\n    })\n\n    const handleInputChange = (event) => {\n        // copy options object\n        const newOptions = { ...options }\n        // Go to the key that matches \"name\" and change the value of that key to match the user's input\n        newOptions[event.target.name] = event.target.value\n        // set state so the DOM re-renders with updated info\n        setOptions(newOptions)\n        // If none of the values in the newOptions object are empty strings\n        if (Object.values(newOptions).includes(\"\") === false) {\n            // isComplete is true, which means all input fields are filled\n            setIsComplete(true)\n        } else {\n            // Prevents app from breaking if a user completely backspaces after completing all fields\n            setIsComplete(false)\n        }\n    }\n\n    const handleSaveClick = () => {\n        // debugger\n        addNewRoute(route)\n        setOptions({\n            name: \"\",\n            originStreet: \"\",\n            originCSZ: \"\",\n            destinationStreet: \"\",\n            destinationCSZ: \"\"\n        })\n        setVisualPath([])\n        setIsComplete(false)\n    }\n\n    useEffect(() => {\n        const currentUserId = parseInt(sessionStorage.getItem(userStorageKey))\n        // Every time setOptions is called to change the options object's value\n        // Decalre a newRoute variable that mirrors route variable layout with concatenated values\n        const newRoute = {\n            name: options.name,\n            origin: options.originStreet + \" \" + options.originCSZ,\n            destination: options.destinationStreet + \" \" + options.destinationCSZ,\n            userId: currentUserId\n        }\n        // change route state to match newRoute\n        setRoute(newRoute)\n        // if all input fields are filled\n        if (isComplete) {\n            getRoutePath(newRoute.origin, newRoute.destination)\n                // sets visualPath state variable equal to array of street names to invoke re-render\n                .then(arrayOfStreetNames => setVisualPath(arrayOfStreetNames))\n        }\n\n    }, [options])\n\n    return (\n        <>\n            <div className=\"formsAndInput\">\n                <fieldset className=\"newRoute__forms--title\">\n                    <legend>Route Name</legend>\n                    <Form.Control type=\"text\" name=\"name\" value={options.name} placeholder=\"Route Name (ex. Home to Work)\" onChange={event => handleInputChange(event)} required></Form.Control>\n                </fieldset>\n                <div className=\"newRoute__forms\">\n                    <Form className=\"newRoute__forms--origin\">\n                        <legend>Origin</legend>\n                        <fieldset>\n                            <Form.Control placeholder=\"Street\" type=\"text\" name=\"originStreet\" value={options.originStreet} onChange={event => handleInputChange(event)} required></Form.Control>\n                        </fieldset>\n\n                        <fieldset>\n                            <label htmlFor=\"originCSZ\"></label>\n                            <Form.Control placeholder=\"City, State Zip\" type=\"text\" name=\"originCSZ\" value={options.originCSZ} onChange={event => handleInputChange(event)} required></Form.Control>\n                        </fieldset>\n\n                    </Form>\n\n                    <Form className=\"newRoute__forms--destination\">\n                        <legend>Destination</legend>\n                        <fieldset>\n                            <Form.Control placeholder=\"Street\" type=\"text\" name=\"destinationStreet\" value={options.destinationStreet} onChange={event => handleInputChange(event)} required></Form.Control>\n                        </fieldset>\n\n                        <fieldset>\n                            <label htmlFor=\"destinationCSZ\"></label>\n                            <Form.Control placeholder=\"City, State Zip\" type=\"text\" name=\"destinationCSZ\" value={options.destinationCSZ} onChange={event => handleInputChange(event)} required></Form.Control>\n                        </fieldset>\n\n                    </Form>\n                </div>\n            </div>\n            <div className=\"newRoute__path\">\n                <Card.Title>Your Route Path</Card.Title>\n                {visualPath.join(\" to \")}\n            </div>\n            <button className=\"btn--saveRoute\" type=\"submit\"\n                // Button is disabled until isComplete equals true\n                // When the user clicks Save Route, invoke handleSaveClick\n                disabled={!isComplete} className=\"save button\" onClick={() => handleSaveClick()}>Save Route</button>\n        </>\n    )\n}","// Responsible for rendering user's Saved Routes and Route Form\nimport React, { useContext, useEffect, useState } from \"react\"\nimport { useHistory } from \"react-router\"\nimport { userStorageKey } from \"../auth/authSettings\"\nimport { RouteCard } from \"./RouteCard\"\nimport { RouteForms } from \"./RouteForms\"\nimport { RouteContext } from \"./RouteProvider\"\nimport \"./RoutePage.css\"\n\nexport const RoutePage = () => {\n    // imports routes state variable and getRoutes function\n    const { routes, getRoutes } = useContext(RouteContext)\n\n    // Declares state variable to be mapped once useEffect runs\n    const [userRoutes, setUserRoutes] = useState([])\n\n    const history = useHistory()\n\n    useEffect(() => {\n        // calls local API to get routes collection\n        getRoutes()\n    }, [])\n\n    useEffect(() => {\n        const currentUserId = parseInt(sessionStorage.getItem(userStorageKey))\n        // filters the array containing all route objects and return and array containing only the objects for the currently logged in user\n        const filteredRoutes = routes.filter(route => route.userId === currentUserId)\n        // sets userRoutes equal to filteredRoutes\n        setUserRoutes(filteredRoutes)\n\n    }, [routes])\n\n    const handleLogout = () => {\n        sessionStorage.removeItem('app_user_id')\n        history.push(\"/\")\n    }\n\n    return (\n        <>\n            <button onClick={() => history.push(\"/edit-profile\")}>Edit Profile Info</button>\n            <h1>Checkpoint</h1>\n            <button className=\"logout\" onClick={() => handleLogout()}>Logout</button>\n            <section className=\"savedRoutes\">\n                <h2>Saved Routes</h2>\n                <p className=\"recheckMessage\">Traffic Incidents are updated periodically, so you may need to Check Traffic again if you're logged in for an extended period</p>\n                <div className=\"savedRoutes__cards\">\n                    {userRoutes.map(route => {\n                        // Invokes RouteCard for every userRoute\n                        return <RouteCard key={route.id} routeObj={route} />\n                    })}\n                </div>\n            </section>\n            <div className=\"newRoute\">\n                <h2>New Route</h2>\n                <div className=\"newRoute__content\">\n                    {/* Invoke RouteForm component to render New Route form to DOM */}\n                    <RouteForms />\n                </div>\n            </div>\n        </>\n    )\n}","import React, { createContext, useState } from \"react\"\nimport { userStorageKey } from \"../auth/authSettings\"\n\nexport const UserContext = createContext()\n\nexport const UserProvider = (props) => {\n\n\n    const [userObject, setUserObject] = useState({})\n\n    const currentUserId = sessionStorage.getItem(userStorageKey)\n\n    const getLoggedInUserObject = () => {\n\n        return fetch(`https://checkpoint--api.herokuapp.com/users/${currentUserId}`)\n            .then(res => res.json())\n            .then(setUserObject)\n    }\n\n    const updateUser = (userObj) => {\n        return fetch(`https://checkpoint--api.herokuapp.com/users/${userObj.id}`, {\n            method: \"PUT\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(userObj)\n        })\n    }\n\n    return (\n        <UserContext.Provider value={{\n            getLoggedInUserObject, userObject, updateUser\n        }}>\n            {props.children}\n        </UserContext.Provider>\n    )\n}","import React, { useContext, useEffect, useState } from \"react\"\nimport Button from 'react-bootstrap/Button';\nimport { UserContext } from \"./UserProvider\"\nimport \"./UserEditForm.css\"\nimport Form from 'react-bootstrap/Form';\nimport { useHistory } from \"react-router\";\n\nexport const UserEditForm = () => {\n    const { getLoggedInUserObject, userObject, updateUser } = useContext(UserContext)\n\n    const history = useHistory()\n\n    const [userToEdit, setUserToEdit] = useState({})\n\n    useEffect(() => {\n        getLoggedInUserObject()\n\n    }, [])\n\n    useEffect(() => {\n        setUserToEdit(userObject)\n    }, [userObject])\n\n    const handleInputChange = (event) => {\n        const updatedUserToEdit = { ...userToEdit }\n        updatedUserToEdit[event.target.name] = event.target.value\n\n        setUserToEdit(updatedUserToEdit)\n    }\n\n    const handleSaveClick = () => {\n        updateUser(userToEdit)\n        history.push(\"/\")\n\n    }\n    \n    return (\n        <Form id=\"modal\">\n            <h3 id=\"userEditHeader\">User Profile Information</h3>\n            <legend htmlFor=\"firstName\">First Name</legend>\n            <Form.Control name=\"firstName\" type=\"text\" value={`${userToEdit.firstName}`} onChange={(event) => handleInputChange(event)}></Form.Control>\n            <legend htmlFor=\"lastName\">Last Name</legend>\n            <Form.Control name=\"lastName\" type=\"text\" value={`${userToEdit.lastName}`} onChange={(event) => handleInputChange(event)}></Form.Control>\n            <legend htmlFor=\"email\">Email</legend>\n            <Form.Control name=\"email\" type=\"text\" value={`${userToEdit.email}`} onChange={(event) => handleInputChange(event)}></Form.Control>\n            <Button id=\"userEditSave\" onClick={() => handleSaveClick()} >Save Changes</Button>\n        </Form>\n    )\n\n}","import { Route, Redirect } from \"react-router-dom\"\nimport { Login } from \"./auth/Login\"\nimport { Register } from \"./auth/Register\"\nimport { userStorageKey } from \"./auth/authSettings\"\nimport { RoutePage } from \"./routes/RoutePage\"\nimport { RouteProvider } from \"./routes/RouteProvider\"\nimport { TrafficProvider } from \"./routes/TrafficProvider\"\nimport { PathsProvider2 } from \"./paths/PathsProvider2\"\nimport { UserProvider } from \"./users/UserProvider\"\nimport { UserEditForm } from \"./users/UserEditForm\"\n\nexport const Checkpoint = () => {\n  return (\n    <>\n      <Route render={() => {\n        if (sessionStorage.getItem(userStorageKey)) {\n          // If the user is logged in\n          return (\n            <>\n            <UserProvider> \n              <RouteProvider>\n                <PathsProvider2>\n                  <TrafficProvider>\n                    <Route exact path=\"/\">\n                      <RoutePage />\n                    </Route>\n                    <Route exact path=\"/edit-profile\">\n                      <UserEditForm />\n                    </Route>\n                  </TrafficProvider>\n                </PathsProvider2>\n              </RouteProvider>\n            </UserProvider>\n            </>\n          )\n        } else {\n          return <Redirect to=\"/login\" />;\n        }\n      }} />\n\n      <Route path=\"/login\">\n        <Login />\n      </Route>\n      <Route path=\"/register\">\n        <Register />\n      </Route>\n    </>\n  )\n}\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Checkpoint } from './components/Checkpoint';\nimport reportWebVitals from './reportWebVitals';\nimport { BrowserRouter as Router } from \"react-router-dom\"\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Router>\n      <Checkpoint />\n    </Router>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}