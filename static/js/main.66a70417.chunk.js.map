{"version":3,"sources":["components/auth/authSettings.js","components/auth/Login.js","components/auth/Register.js","components/paths/PathsProvider2.js","components/routes/RouteProvider.js","modules/RouteStreetNames.js","components/routes/TrafficProvider.js","components/routes/RouteCard.js","components/routes/RouteForms.js","components/routes/RoutePage.js","components/users/UserProvider.js","components/users/UserEditForm.js","components/Checkpoint.js","reportWebVitals.js","index.js"],"names":["authApi","userStorageKey","Login","useState","email","loginUser","setLoginUser","history","useHistory","className","onSubmit","e","preventDefault","fetch","then","res","json","user","length","exists","sessionStorage","setItem","id","push","window","alert","htmlFor","type","placeholder","required","autoFocus","value","onChange","event","newUser","target","to","Register","firstName","lastName","registerUser","setRegisterUser","conflictDialog","setConflictDialog","handleInputChange","style","textAlign","open","onClick","userExists","method","headers","body","JSON","stringify","createdUser","hasOwnProperty","name","PathsContext","createContext","PathsProvider2","props","useContext","RouteContext","getLatLong","getRoutePath","newRoute","useEffect","origin","arrayOfPromises","finalLatLong","latLongStreetObjects","finalArrayOfStreetNames","destination","arrayOfStreetNames","map","streetName","Promise","all","optionsArray","forEach","options","splitOrigin","split","splitDestination","splice","originCity","destinationCity","optionsStreetNamesString","items","itemObj","title","join","toLowerCase","includes","find","item","a","Object","values","position","i","newRoutePath","latLong","routeId","order","postRoutePath","timer","destructuredLat","destructuredLong","ms","setTimeout","routePathObj","Provider","getPathByRouteId","routeObj","children","RouteProvider","routes","setRoutes","setNewRoute","address","process","getDirections","originObj","destinationObj","addNewRoute","getRoutes","routesArray","getRouteById","routeObjId","deleteRoute","updateRoute","userId","originLatLong","destinationLatLong","directions","route","originString","filteredStreetNames","sections","turnByTurnActions","filter","undefined","nextRoad","streetNames","actionObj","number","finalStreetNamesWithoutDuplicates","Set","finalSpecificStreetNames","originState","getRouteStreetNames","TrafficContext","TrafficProvider","incidents","setIncidents","getTrafficIncidentData","latLongString","replace","ok","console","log","getIncidentAndLocation","routePathArray","streetNameObj","RouteCard","incidentsToPost","setIncidentsToPost","eventId","setEventId","messageToPost","setMessageToPost","editClicked","setEditClicked","routeToEdit","setRouteToEdit","isComplete","setIsComplete","visualPath","setVisualPath","TRAFFICITEMS","TRAFFICITEM","incident","Card","Text","TRAFFICITEMDESCRIPTION","content","Math","random","addDiv","handleChangeInput","newRouteToEdit","Body","Button","handleViewPathClick","Title","parseInt","handleCheckTrafficClick","ButtonGroup","aria-label","disabled","RouteForms","setRoute","originStreet","originCSZ","destinationStreet","destinationCSZ","setOptions","newOptions","currentUserId","getItem","Form","Control","RoutePage","userRoutes","setUserRoutes","filteredRoutes","removeItem","UserContext","UserProvider","userObject","setUserObject","getLoggedInUserObject","updateUser","userObj","UserEditForm","userToEdit","setUserToEdit","updatedUserToEdit","Checkpoint","render","exact","path","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.66a70417.chunk.js","sourcesContent":["// If your json-server API URL or endpoint is different, please change it below!\nexport const authApi = {\n  localApiBaseUrl: \"https://checkpoint--api.herokuapp.com\",\n  endpoint: \"users\"\n}\n\n// The user id is saved under the key app_user_id in session Storage. Change below if needed!\nexport const userStorageKey = \"app_user_id\"\n\n\n\n\n","import React, { useState } from \"react\"\nimport { Link, useHistory } from \"react-router-dom\";\nimport { authApi, userStorageKey } from \"./authSettings\"\n\nexport const Login = () => {\n    const [loginUser, setLoginUser] = useState({ email: \"jisie@jisie.com\" })\n    // const [existDialog, setExistDialog] = useState(false)\n\n    const history = useHistory()\n\n    const handleInputChange = (event) => {\n        const newUser = { ...loginUser }\n        newUser[event.target.id] = event.target.value\n        setLoginUser(newUser)\n    }\n\n\n    const existingUserCheck = () => {\n        return fetch(`${authApi.localApiBaseUrl}/${authApi.endpoint}?email=${loginUser.email}`)\n            .then(res => res.json())\n            .then(user => user.length ? user[0] : false)\n    }\n\n    const handleLogin = (e) => {\n        e.preventDefault()\n\n        existingUserCheck()\n            .then(exists => {\n                if (exists) {\n                    sessionStorage.setItem(userStorageKey, exists.id)\n                    history.push(\"/\")\n                } else {\n                    // setExistDialog(true)\n                    window.alert(\"Invalid email address\")\n                }\n            })\n    }\n\n    return (\n        <main className=\"container--login\">\n            {/* <dialog className=\"dialog dialog--auth\" open={existDialog}>\n                <div>User does not exist</div>\n                <button className=\"button--close\" onClick={e => setExistDialog(false)}>Close</button>\n            </dialog> */}\n            <section>\n                <form className=\"form--login\" onSubmit={handleLogin}>\n                    <h1>Checkpoint</h1>\n                    <h2>Please sign in</h2>\n                    <fieldset>\n                        <label htmlFor=\"inputEmail\"> Email address </label>\n                        <input type=\"email\"\n                            id=\"email\"\n                            className=\"form-control\"\n                            placeholder=\"Email address\"\n                            required autoFocus\n                            value={loginUser.email}\n                            onChange={handleInputChange} />\n                    </fieldset>\n                    <fieldset>\n                        <button type=\"submit\">\n                            Sign in\n                        </button>\n                    </fieldset>\n                </form>\n            </section>\n            <section className=\"link--register\">\n                <Link to=\"/register\">Register for an account</Link>\n            </section>\n        </main>\n    )\n}\n\n","import React, { useState } from \"react\"\nimport { useHistory } from \"react-router-dom\"\nimport { authApi, userStorageKey } from \"./authSettings\"\n\nexport const Register = () => {\n\n    const [registerUser, setRegisterUser] = useState({ firstName: \"\", lastName: \"\", email: \"\" })\n    const [conflictDialog, setConflictDialog] = useState(false)\n\n    const history = useHistory()\n\n    const handleInputChange = (event) => {\n        const newUser = { ...registerUser }\n        newUser[event.target.id] = event.target.value\n        setRegisterUser(newUser)\n    }\n\n    const existingUserCheck = () => {\n        \n        return fetch(`${authApi.localApiBaseUrl}/${authApi.endpoint}?email=${registerUser.email}`)\n            .then(res => res.json())\n            .then(user => !!user.length)\n    }\n\n    const handleRegister = (e) => {\n        e.preventDefault()\n\n        existingUserCheck()\n            .then((userExists) => {\n                if (!userExists) {\n                    fetch(`${authApi.localApiBaseUrl}/${authApi.endpoint}`, {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            email: registerUser.email,\n                            firstName: registerUser.firstName,\n                            lastName: registerUser.lastName\n                        })\n                    })\n                        .then(res => res.json())\n                        .then(createdUser => {\n                            if (createdUser.hasOwnProperty(\"id\")) {\n                                sessionStorage.setItem(userStorageKey, createdUser.id)\n                                history.push(\"/\")\n                            }\n                        })\n                }\n                else {\n                    setConflictDialog(true)\n                }\n            })\n\n    }\n\n    return (\n        <main style={{ textAlign: \"center\" }}>\n\n            <dialog className=\"dialog dialog--password\" open={conflictDialog}>\n                <div>Account with that email address already exists</div>\n                <button className=\"button--close\" onClick={e => setConflictDialog(false)}>Close</button>\n            </dialog>\n\n            <form className=\"form--login\" onSubmit={handleRegister}>\n                <h1 className=\"h3 mb-3 font-weight-normal\">Please Register for Application Name</h1>\n                <fieldset>\n                    <label htmlFor=\"firstName\"> First Name </label>\n                    <input type=\"text\" name=\"firstName\" id=\"firstName\" className=\"form-control\" placeholder=\"First name\" required autoFocus value={registerUser.firstName} onChange={handleInputChange} />\n                </fieldset>\n                <fieldset>\n                    <label htmlFor=\"lastName\"> Last Name </label>\n                    <input type=\"text\" name=\"lastName\" id=\"lastName\" className=\"form-control\" placeholder=\"Last name\" required value={registerUser.lastName} onChange={handleInputChange} />\n                </fieldset>\n                <fieldset>\n                    <label htmlFor=\"inputEmail\"> Email address </label>\n                    <input type=\"email\" name=\"email\" id=\"email\" className=\"form-control\" placeholder=\"Email address\" required value={registerUser.email} onChange={handleInputChange} />\n                </fieldset>\n                <fieldset>\n                    <button type=\"submit\"> Sign in </button>\n                </fieldset>\n            </form>\n        </main>\n    )\n}\n\n","import React, { createContext, useContext, useEffect } from \"react\"\nimport { RouteContext } from \"../routes/RouteProvider\"\n\nexport const PathsContext = createContext()\n\nexport const PathsProvider2 = (props) => {\n    const { getLatLong, getRoutePath, newRoute } = useContext(RouteContext)\n    useEffect(() => {\n\n        if (newRoute.origin) {\n            let arrayOfPromises = []\n            let finalLatLong = []\n            let latLongStreetObjects = []\n            let finalArrayOfStreetNames = []\n            let origin = newRoute.origin\n            let destination = newRoute.destination\n            getRoutePath(newRoute.origin, newRoute.destination)\n                .then(arrayOfStreetNames => {\n                    arrayOfPromises = arrayOfStreetNames.map(streetName => {\n                        // Runs each street name string through the geocoder API to get the lat/long\n                        return getLatLong(streetName)\n                    })\n                    // Waits for arrayOfPromises to return and then returns that result (the lat/long of each street name)\n                    return Promise.all(arrayOfPromises)\n                })\n                .then(optionsArray => {\n                    // optionsArray is an array of objects where each object contains an array of objects representing a potential street name\n                    optionsArray.forEach(options => {\n                        // Splices the origin and destination string into an array of strings\n                        const splitOrigin = origin.split(\" \")\n                        const splitDestination = destination.split(\" \")\n\n                        // returns an array of a single string representing city name\n                        const [originCity] = splitOrigin.splice(-3, 1)\n                        const [destinationCity] = splitDestination.splice(-3, 1)\n\n                        // Returns an array of just street name strings, includes steet address, city, state, zip\n                        const optionsStreetNames = options.items.map(itemObj => itemObj.title)\n\n                        // Joins entire array of street names to create 1 single string containing all potential street names\n                        const optionsStreetNamesString = optionsStreetNames.join(\"\")\n\n                        // Checks to see if the joined string of all street names contains origin or destination city\n                        if (optionsStreetNamesString.toLowerCase().includes(`${originCity.toLowerCase()}`) || optionsStreetNamesString.toLowerCase().includes(`${destinationCity.toLowerCase()}`)) {\n                            // If true, push the first street name object that contains origin or destination city into latLongStreetObjects array\n                            latLongStreetObjects.push(options.items.find(item => item.title.toLowerCase().includes(`${originCity.toLowerCase()}`) || item.title.toLowerCase().includes(`${destinationCity.toLowerCase()}`)))\n                        } else {\n                            // If false, push an empty string (placeholder) into array\n                            latLongStreetObjects.push(\" \")\n                        }\n                    })\n                })\n                // Uses async/await so that the entire function runs and then awaits completion of specified function\n                .then(async () => {\n                    // Maps array of street name objects and pushes either the placeholder empty string or the lat/long into finalLatLong\n                    latLongStreetObjects.map(item => item === \" \" ? finalLatLong.push(\"\") : finalLatLong.push(Object.values(item.position)))\n\n                    // Runs everything inside the loop as many times as there are items in finalLatLong\n                    for (let i = 0; i < finalLatLong.length; i++) {\n                        // For placeholder strings, create path objects with empty string in place of latLong\n                        if (finalLatLong[i] === \"\") {\n                            const newRoutePath = {\n                                streetName: finalArrayOfStreetNames[i],\n                                latLong: finalLatLong[i],\n                                routeId: newRoute.id,\n                                order: i + 1\n                            }\n                            postRoutePath(newRoutePath)\n                            await timer(50)\n                        } else {\n                            // Where lat/long are not empty strings, use lat/long fot latlong\n                            const [destructuredLat, destructuredLong] = finalLatLong[i]\n                            const newRoutePath = {\n                                streetName: finalArrayOfStreetNames[i],\n                                latLong: destructuredLat + \", \" + destructuredLong,\n                                routeId: newRoute.id,\n                                order: i + 1\n                            }\n                            postRoutePath(newRoutePath)\n                            // Waits 50 ms between posts to prevent 429 error\n                            await timer(50)\n\n                        }\n                    }\n                })\n        }\n    }, [newRoute])\n\n    const timer = ms => new Promise(res => {\n        setTimeout(res, ms)\n    })\n\n    const postRoutePath = (routePathObj) => {\n        return fetch(`https://checkpoint--api.herokuapp.com/paths`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(routePathObj)\n        })\n    }\n\n    const getPathByRouteId = (routeObj) => {\n        return fetch(`https://checkpoint--api.herokuapp.com/paths?routeId=${routeObj.id}`)\n            .then(res => res.json())\n    }\n\n\n    return (\n        <PathsContext.Provider value={{\n            getPathByRouteId\n        }}>\n            {props.children}\n        </PathsContext.Provider>\n    )\n}","import React, { createContext, useEffect, useState } from \"react\"\nimport { getRouteStreetNames } from \"../../modules/RouteStreetNames\"\nimport { PathsProvider2 } from \"../paths/PathsProvider2\"\n\nexport const RouteContext = createContext()\n\nexport const RouteProvider = (props) => {\n    const [routes, setRoutes] = useState([])\n\n    const [newRoute, setNewRoute] = useState({})\n    const [routeToEditRoutePath, setRouteToEditRoutePath] = useState({})\n\n    //  Use HERE GeoCoding and Search API to convert street addresses to lat/long pair\n    const getLatLong = (address) => {\n        return fetch(`https://geocode.search.hereapi.com/v1/geocode?q=${address}&apiKey=${process.env.REACT_APP_API}`,)\n            .then(res => res.json())\n    }\n\n    // HERE Router API creates path from origin to destination\n    // Uses string interpolation to insert the values (lat/long) of the origin and destination objects\n    const getDirections = (originObj, destinationObj) => {\n        return fetch(`https://router.hereapi.com/v8/routes?transportMode=car&origin=${Object.values(originObj)}&destination=${Object.values(destinationObj)}&return=polyline,turnbyturnactions&apikey=${process.env.REACT_APP_API}`)\n            .then(res => res.json())\n    }\n\n    const addNewRoute = routeObj => {\n        return fetch(`https://checkpoint--api.herokuapp.com/routes`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(routeObj)\n        })\n        .then(res => res.json())\n        .then(setNewRoute)\n        .then(getRoutes)\n        .then(() => <PathsProvider2 />)\n\n    }\n    //set routes state variable equal to an array of all routes \n    const getRoutes = () => {\n        return fetch(\"https://checkpoint--api.herokuapp.com/routes\")\n            .then(res => res.json())\n            .then(routesArray => setRoutes(routesArray))\n    }\n\n    const getRouteById = (routeObjId) => {\n        return fetch(`https://checkpoint--api.herokuapp.com/routes/${routeObjId}?_embed=path`)\n            .then(res => res.json())\n    }\n\n    const deleteRoute = (routeId) => {\n        return fetch(`https://checkpoint--api.herokuapp.com/routes/${routeId}`, {\n            method: \"DELETE\"\n        })\n            .then(getRoutes)\n    }\n\n    const updateRoute = routeObj => {\n        return fetch(`https://checkpoint--api.herokuapp.com/routes/${routeObj.id}`, {\n            method: \"DELETE\"\n        })\n        .then(() => addNewRoute({\n            \"name\": routeObj.name,\n            \"origin\": routeObj.origin,\n            \"destination\": routeObj.destination,\n            \"userId\": routeObj.userId\n        }))\n    }\n\n    const getRoutePath = (origin, destination) => {\n        let originLatLong = {}\n        let destinationLatLong = {}\n        return getLatLong(origin)\n            .then(res => {\n                // res.items[0].position is an object containing lat and long as key value pairs\n                return originLatLong = res.items[0].position\n            })\n            .then(() => getLatLong(destination))\n            .then(res => {\n                // changes empty object variable equal to an object containing lat/long pair\n                return destinationLatLong = res.items[0].position\n            })\n            // Returns turn by turn directions from origin to destination\n            .then(() => getDirections(originLatLong, destinationLatLong))\n            // Returns an array of strings, where wach string is the next street a user should take \n            .then(directions => getRouteStreetNames(directions, origin))\n    }\n\n    return (\n        <RouteContext.Provider value={{\n            getLatLong, getDirections, addNewRoute, getRoutes, routes, getRouteById, deleteRoute, updateRoute, getRoutePath, newRoute\n\n        }}>\n            {props.children}\n        </RouteContext.Provider>\n    )\n}","// Returns an array of just street names that the user will follow during their drive\n\nexport const getRouteStreetNames = (route, originString) => {\n    // route.routes[0].sections[0].turnByTurnActions is an array of action objects like arrive, turn, continue\n    const turnByTurnDirections = route.routes[0].sections[0].turnByTurnActions\n\n    // Removes any action that doesn't contain a nextRoad value, because nextRoad conatins the street names that will be rendered\n    // Removes things like depart, arrive, continue\n    const filteredStreetNames = turnByTurnDirections.filter(name => name.nextRoad !== undefined)\n\n    // Stores only the key/value pairs that start with \"name\" or \"number\"\n    const streetNames = []\n    filteredStreetNames.forEach((actionObj) => actionObj.nextRoad.name ? streetNames.push(actionObj.nextRoad.name[0].value) : streetNames.push(actionObj.nextRoad.number[0].value))\n\n    // Creates a new set of street names where each street is only listed once; removes actions like \"continue\"\n    let finalStreetNamesWithoutDuplicates = [... new Set(streetNames)]\n\n    let finalSpecificStreetNames = []\n\n    if (originString) {\n\n        let splitOrigin = originString.split(\" \")\n        let [originState] = splitOrigin.splice(-2, 1)\n\n        finalStreetNamesWithoutDuplicates.forEach(name => {\n\n            finalSpecificStreetNames.push(name + \" \" + originState)\n        })\n        return finalSpecificStreetNames\n\n    } else {\n        return finalStreetNamesWithoutDuplicates\n    }\n    \n}","import React, { createContext, useContext, useState } from \"react\"\nimport { getRouteStreetNames } from \"../../modules/RouteStreetNames\"\nimport { PathsContext } from \"../paths/PathsProvider2\"\nimport { RouteContext } from \"./RouteProvider\"\n\nexport const TrafficContext = createContext()\n\nexport const TrafficProvider = (props) => {\n    // Declares state variable that can be set once traffice data is returned\n    const [incidents, setIncidents] = useState({})\n\n    // imports functions to be used in this component\n    const { getLatLong, getDirections, getRouteById } = useContext(RouteContext)\n\n    const { getPathByRouteId } = useContext(PathsContext)\n\n    const getIncidentAndLocation = (routeObj) => {\n        // Returns an array of path objects from database\n        return getPathByRouteId(routeObj)\n        .then(routePathArray => {\n            let latLongString = \"\"\n            // Iterates over each path object\n            // If latLong contains a lat/long add the lat/long to latLongString with a semicolon at the end\n            routePathArray.forEach(streetNameObj => streetNameObj.latLong !== \"\" ? latLongString = latLongString + streetNameObj.latLong + \";\" : latLongString)\n            return getTrafficIncidentData(latLongString)\n        })\n    }\n\n    const getTrafficIncidentData = (latLongString) => {\n        //Replaces spaces with empty strings\n        latLongString = latLongString.replace(/\\s+/g,'')\n\n        return fetch(`https://infinite-scrubland-76177.herokuapp.com/https://traffic.ls.hereapi.com/traffic/6.0/incidents.json?corridor=${latLongString}20&apiKey=${process.env.REACT_APP_API}`)\n            .then(res => {\n                if (res.ok) {\n                    // Tells me I got a good res\n                    console.log(\"got a good response\", res)\n                    return res.json()\n                } else {\n                    // Tells me I got a bad response\n                    console.log(\"you don't want that response\")\n\n                }\n            })\n            // sets incidents equal to data that was returned from fetch call\n            .then(res => {\n                setIncidents(res)\n            })\n    }\n\n    return (\n        <TrafficContext.Provider value={{\n            getIncidentAndLocation, incidents\n        }}>\n            {props.children}\n        </TrafficContext.Provider>\n    )\n\n}","import React, { useContext, useEffect, useState } from \"react\"\nimport { RouteContext } from \"./RouteProvider\"\nimport { TrafficContext } from \"./TrafficProvider\"\nimport Button from 'react-bootstrap/Button';\nimport Card from 'react-bootstrap/Card';\nimport { ButtonGroup } from 'react-bootstrap';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport \"./RouteCard.css\"\n\nexport const RouteCard = ({ routeObj }) => {\n    const { getIncidentAndLocation, incidents } = useContext(TrafficContext)\n\n    const { deleteRoute, getRouteById, updateRoute, getRoutePath } = useContext(RouteContext)\n\n    // state variable that will contain traffic incidents for a certain route\n    const [incidentsToPost, setIncidentsToPost] = useState([])\n    // Will store event.target.id after CheckTraffic is clicked\n    const [eventId, setEventId] = useState(0)\n    // Will store the message to be posted to the DOM on the appropriate card\n    const [messageToPost, setMessageToPost] = useState(<div></div>)\n    // Will be used to determine when to show buttons/input vs text\n    const [editClicked, setEditClicked] = useState(false)\n    // will be used to generate fields for input and handle changes to route\n    const [routeToEdit, setRouteToEdit] = useState({})\n    // Will be used to determine if all fields are complete\n    const [isComplete, setIsComplete] = useState(false)\n    // Will be used to cause re-render when array of street names is ready to be displayed on DOM\n    const [visualPath, setVisualPath] = useState([])\n\n    // TRAFFIC INFO\n\n    const handleCheckTrafficClick = (event) => {\n        // Gets incident data from API and sets incidents equal to the response object\n        getIncidentAndLocation(routeObj)\n            .then(() => {\n                // Sets eventId equal to event.target.id (id of the route where the button was clicked)\n                setEventId(parseInt(event.target.id))\n            })\n    }\n\n    const addDiv = () => {\n        // If eventId === the id of the object that was clicked\n        if (eventId === routeObj.id) {\n            // If IncidentsToPost is not undefined\n            if (incidentsToPost) {\n                // returns the content message for each incident\n                return (\n\n                    <div className=\"incidentMessage\"><h5>Traffic Incidents</h5> {incidentsToPost.map(incident => <Card.Text key={Math.random()}>{incident?.TRAFFICITEMDESCRIPTION[0].content}</Card.Text>)}</div>\n                )\n            } else {\n                // Returns all clear message if there are no incident objects in the array\n                return <Card.Text className=\"incidentMessage\">All clear! There are no incidents blocking your route</Card.Text>\n            }\n        }\n    }\n\n    useEffect(() => {\n        // When incidents variable changes, incidentsToPost is set equal to an array incident objects\n        setIncidentsToPost(incidents?.TRAFFICITEMS?.TRAFFICITEM)\n    }, [incidents])\n\n    useEffect(() => {\n        // When eventId set messageToPost equal to whatever is returned from the addDiv function\n        setMessageToPost(addDiv())\n    }, [eventId])\n\n    // DELETE\n\n    const handleDeleteClick = () => {\n        deleteRoute(routeObj.id)\n    }\n\n    // EDIT\n\n    const handleEditClick = () => {\n        // Get the route that needs to be edited\n        getRouteById(routeObj.id)\n            // set routeToEdit equal to the routeObj returned from the fetch call\n            .then(routeObj => setRouteToEdit(routeObj))\n    }\n\n    const handleChangeInput = (event) => {\n        // copy the route\n        const newRouteToEdit = { ...routeToEdit }\n        // Go to the key that matches the id of the input field being changed and reassign that key to whatever the user typed\n        newRouteToEdit[event.target.id] = event.target.value\n        // set routeToEdit equal to the changed route\n        setRouteToEdit(newRouteToEdit)\n    }\n\n    const handleViewPathClick = () => {\n        const newRouteToEdit = { ...routeToEdit }\n        // returns an array of strings; each string is a street name\n        getRoutePath(newRouteToEdit.origin, newRouteToEdit.destination)\n            \n            // set path equal to the array of street names so the user can view the street names on their route\n            .then(arrayOfStreetNames => setVisualPath(arrayOfStreetNames))\n    }\n\n    useEffect(() => {\n        // Checks to see if the route is at least 15 characters long; allows the user to save the route even if they don't make changes\n        if (routeToEdit.origin?.length > 15 && routeToEdit.destination?.length > 15) {\n            setIsComplete(true)\n        } else {\n            setIsComplete(false)\n        }\n    }, [routeToEdit])\n\n    const handleSaveClick = () => {\n        // Update the route in the database to match the changed route\n        updateRoute(routeToEdit)\n        // sets path back to an empty array ro remove the route path from the card\n        setVisualPath([])\n    }\n\n    return (\n        <Card className=\"savedRoutes__cards--routeCard\">\n            {/* Checks to see if editClicked is true */}\n            {editClicked ?\n                <>\n                    {/* IF TRUE, display inout field/textarea fields containing route name, origin, and destination that the user can change */}\n                    <div className=\"allEditFields\">\n                        <legend>Route Name</legend>\n                        <input id={\"name\"} type=\"text\" value={routeToEdit.name} onChange={event => handleChangeInput(event)}></input>\n                        <div className=\"legends\"><legend>Origin</legend><legend>Destination</legend></div>\n                        <div className=\"addressEditFields\">\n                            <textarea id={\"origin\"} type=\"text\" value={routeToEdit.origin} onChange={event => handleChangeInput(event)}></textarea>\n                            <textarea id={\"destination\"} type=\"text\" value={routeToEdit.destination} onChange={event => handleChangeInput(event)}></textarea>\n                        </div>\n                    </div>\n                    <Card.Body className=\"newRoute__path\">\n                        <h3>Your Route Path</h3>\n                        <p className=\"editedRoutePath\">{visualPath.join(\" to \")}</p>\n                        <Button className=\"route button\" onClick={() => handleViewPathClick()}>View Route Path</Button>\n                    </Card.Body>\n                </>\n                // IF FALSE, just display the route name as a header\n                : <Card.Title>{routeObj.name}</Card.Title>}\n\n            {editClicked ? \"\" :\n                <>\n                    {messageToPost}\n                    <Button className=\"traffic button\" id={routeObj.id} onClick={(event) => { handleCheckTrafficClick(event) }}>Check Traffic</Button>\n                </>\n            }\n\n            {/* Checks to see if editClicked is true */}\n            <ButtonGroup aria-label=\"First group\">\n                {editClicked ?\n                    // If true, display a Save button; disabled when any field is incomplete \n                    <Button className=\"save button\" disabled={!isComplete} onClick={() => { handleSaveClick(); setEditClicked(false) }} id={`${routeObj.id}`}>Save Changes</Button>\n                    // If false, display Edit button\n                    : <Button className=\"edit button\" onClick={() => { handleEditClick(); setEditClicked(true) }} id={`${routeObj.id}`}>Edit</Button>}\n                {/* Delete button */}\n                <Button className=\"delete button\" onClick={() => handleDeleteClick()}>Delete Route</Button>\n            </ButtonGroup>\n        </Card>\n    )\n}","// Reponsible for Route Form layout and state\nimport React, { useContext, useState, useEffect } from \"react\"\nimport { userStorageKey } from \"../auth/authSettings\"\nimport { RouteContext } from \"./RouteProvider\"\nimport Form from 'react-bootstrap/Form';\nimport { Card } from \"react-bootstrap\"\nimport \"./RouteForm.css\"\n\nexport const RouteForms = () => {\n    // imports functions to be used in this component\n    const { addNewRoute, getRoutePath } = useContext(RouteContext)\n    // Will be used to determine if all form fields are filled\n    const [isComplete, setIsComplete] = useState(false)\n    // Will be used to cause re-render when array of street names is ready to be displayed on DOM\n    const [visualPath, setVisualPath] = useState([\"Don't forget to check your path before clicking Save!\"])\n    // Will be used to save route to database\n    const [route, setRoute] = useState({})\n    // Because an input field can't be matched to a route key, this state variable will be used until all fields are ready to setRoute\n    const [options, setOptions] = useState({\n        name: \"\",\n        originStreet: \"\",\n        originCSZ: \"\",\n        destinationStreet: \"\",\n        destinationCSZ: \"\"\n    })\n\n    const handleInputChange = (event) => {\n        // copy options object\n        const newOptions = { ...options }\n        // Go to the key that matches \"name\" and change the value of that key to match the user's input\n        newOptions[event.target.name] = event.target.value\n        // set state so the DOM re-renders with updated info\n        setOptions(newOptions)\n        // If none of the values in the newOptions object are empty strings\n        if (Object.values(newOptions).includes(\"\") === false) {\n            // isComplete is true, which means all input fields are filled\n            setIsComplete(true)\n        } else {\n            // Prevents app from breaking if a user completely backspaces after completing all fields\n            setIsComplete(false)\n        }\n    }\n\n    const handleSaveClick = () => {\n        // debugger\n        addNewRoute(route)\n        setOptions({\n            name: \"\",\n            originStreet: \"\",\n            originCSZ: \"\",\n            destinationStreet: \"\",\n            destinationCSZ: \"\"\n        })\n        setVisualPath([])\n        setIsComplete(false)\n    }\n\n    useEffect(() => {\n        const currentUserId = parseInt(sessionStorage.getItem(userStorageKey))\n        // Every time setOptions is called to change the options object's value\n        // Decalre a newRoute variable that mirrors route variable layout with concatenated values\n        const newRoute = {\n            name: options.name,\n            origin: options.originStreet + \" \" + options.originCSZ,\n            destination: options.destinationStreet + \" \" + options.destinationCSZ,\n            userId: currentUserId\n        }\n        // change route state to match newRoute\n        setRoute(newRoute)\n        // if all input fields are filled\n        if (isComplete) {\n            getRoutePath(newRoute.origin, newRoute.destination)\n                // sets visualPath state variable equal to array of street names to invoke re-render\n                .then(arrayOfStreetNames => setVisualPath(arrayOfStreetNames))\n        }\n\n    }, [options])\n\n    return (\n        <>\n            <div className=\"formsAndInput\">\n                <fieldset className=\"newRoute__forms--title\">\n                    <legend>Route Name</legend>\n                    <Form.Control type=\"text\" name=\"name\" value={options.name} placeholder=\"Route Name (ex. Home to Work)\" onChange={event => handleInputChange(event)} required></Form.Control>\n                </fieldset>\n                <div className=\"newRoute__forms\">\n                    <Form className=\"newRoute__forms--origin\">\n                        <legend>Origin</legend>\n                        <fieldset>\n                            <Form.Control placeholder=\"Street\" type=\"text\" name=\"originStreet\" value={options.originStreet} onChange={event => handleInputChange(event)} required></Form.Control>\n                        </fieldset>\n\n                        <fieldset>\n                            <label htmlFor=\"originCSZ\"></label>\n                            <Form.Control placeholder=\"City, State Zip\" type=\"text\" name=\"originCSZ\" value={options.originCSZ} onChange={event => handleInputChange(event)} required></Form.Control>\n                        </fieldset>\n\n                    </Form>\n\n                    <Form className=\"newRoute__forms--destination\">\n                        <legend>Destination</legend>\n                        <fieldset>\n                            <Form.Control placeholder=\"Street\" type=\"text\" name=\"destinationStreet\" value={options.destinationStreet} onChange={event => handleInputChange(event)} required></Form.Control>\n                        </fieldset>\n\n                        <fieldset>\n                            <label htmlFor=\"destinationCSZ\"></label>\n                            <Form.Control placeholder=\"City, State Zip\" type=\"text\" name=\"destinationCSZ\" value={options.destinationCSZ} onChange={event => handleInputChange(event)} required></Form.Control>\n                        </fieldset>\n\n                    </Form>\n                </div>\n            </div>\n            <div className=\"newRoute__path\">\n                <Card.Title>Your Route Path</Card.Title>\n                {visualPath.join(\" to \")}\n            </div>\n            <button className=\"btn--saveRoute\" type=\"submit\"\n                // Button is disabled until isComplete equals true\n                // When the user clicks Save Route, invoke handleSaveClick\n                disabled={!isComplete} className=\"save button\" onClick={() => handleSaveClick()}>Save Route</button>\n        </>\n    )\n}","// Responsible for rendering user's Saved Routes and Route Form\nimport React, { useContext, useEffect, useState } from \"react\"\nimport { useHistory } from \"react-router\"\nimport { userStorageKey } from \"../auth/authSettings\"\nimport { RouteCard } from \"./RouteCard\"\nimport { RouteForms } from \"./RouteForms\"\nimport { RouteContext } from \"./RouteProvider\"\nimport \"./RoutePage.css\"\n\nexport const RoutePage = () => {\n    // imports routes state variable and getRoutes function\n    const { routes, getRoutes } = useContext(RouteContext)\n\n    // Declares state variable to be mapped once useEffect runs\n    const [userRoutes, setUserRoutes] = useState([])\n\n    const history = useHistory()\n\n    useEffect(() => {\n        // calls local API to get routes collection\n        getRoutes()\n    }, [])\n\n    useEffect(() => {\n        const currentUserId = parseInt(sessionStorage.getItem(userStorageKey))\n        // filters the array containing all route objects and return and array containing only the objects for the currently logged in user\n        const filteredRoutes = routes.filter(route => route.userId === currentUserId)\n        // sets userRoutes equal to filteredRoutes\n        setUserRoutes(filteredRoutes)\n\n    }, [routes])\n\n    const handleLogout = () => {\n        sessionStorage.removeItem('app_user_id')\n        history.push(\"/\")\n    }\n\n    return (\n        <>\n            <button onClick={() => history.push(\"/edit-profile\")}>Edit Profile Info</button>\n            <h1>Checkpoint</h1>\n            <button className=\"logout\" onClick={() => handleLogout()}>Logout</button>\n            <section className=\"savedRoutes\">\n                <h2>Saved Routes</h2>\n                <p className=\"recheckMessage\">Traffic Incidents are updated periodically, so you may need to Check Traffic again if you're logged in for an extended period</p>\n                <div className=\"savedRoutes__cards\">\n                    {userRoutes.map(route => {\n                        // Invokes RouteCard for every userRoute\n                        return <RouteCard key={route.id} routeObj={route} />\n                    })}\n                </div>\n            </section>\n            <div className=\"newRoute\">\n                <h2>New Route</h2>\n                <div className=\"newRoute__content\">\n                    {/* Invoke RouteForm component to render New Route form to DOM */}\n                    <RouteForms />\n                </div>\n            </div>\n        </>\n    )\n}","import React, { createContext, useState } from \"react\"\nimport { userStorageKey } from \"../auth/authSettings\"\n\nexport const UserContext = createContext()\n\nexport const UserProvider = (props) => {\n\n\n    const [userObject, setUserObject] = useState({})\n\n    const currentUserId = sessionStorage.getItem(userStorageKey)\n\n    const getLoggedInUserObject = () => {\n\n        return fetch(`https://checkpoint--api.herokuapp.com/users/${currentUserId}`)\n            .then(res => res.json())\n            .then(setUserObject)\n    }\n\n    const updateUser = (userObj) => {\n        return fetch(`https://checkpoint--api.herokuapp.com/users/${userObj.id}`, {\n            method: \"PUT\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(userObj)\n        })\n    }\n\n    return (\n        <UserContext.Provider value={{\n            getLoggedInUserObject, userObject, updateUser\n        }}>\n            {props.children}\n        </UserContext.Provider>\n    )\n}","import React, { useContext, useEffect, useState } from \"react\"\nimport Button from 'react-bootstrap/Button';\nimport { UserContext } from \"./UserProvider\"\nimport \"./UserEditForm.css\"\nimport Form from 'react-bootstrap/Form';\nimport { useHistory } from \"react-router\";\n\nexport const UserEditForm = () => {\n    const { getLoggedInUserObject, userObject, updateUser } = useContext(UserContext)\n\n    const history = useHistory()\n\n    const [userToEdit, setUserToEdit] = useState({})\n\n    useEffect(() => {\n        getLoggedInUserObject()\n\n    }, [])\n\n    useEffect(() => {\n        setUserToEdit(userObject)\n    }, [userObject])\n\n    const handleInputChange = (event) => {\n        const updatedUserToEdit = { ...userToEdit }\n        updatedUserToEdit[event.target.name] = event.target.value\n\n        setUserToEdit(updatedUserToEdit)\n    }\n\n    const handleSaveClick = () => {\n        updateUser(userToEdit)\n        history.push(\"/\")\n\n    }\n    \n    return (\n        <Form id=\"modal\">\n            <h3 id=\"userEditHeader\">User Profile Information</h3>\n            <legend htmlFor=\"firstName\">First Name</legend>\n            <Form.Control name=\"firstName\" type=\"text\" value={`${userToEdit.firstName}`} onChange={(event) => handleInputChange(event)}></Form.Control>\n            <legend htmlFor=\"lastName\">Last Name</legend>\n            <Form.Control name=\"lastName\" type=\"text\" value={`${userToEdit.lastName}`} onChange={(event) => handleInputChange(event)}></Form.Control>\n            <legend htmlFor=\"email\">Email</legend>\n            <Form.Control name=\"email\" type=\"text\" value={`${userToEdit.email}`} onChange={(event) => handleInputChange(event)}></Form.Control>\n            <Button id=\"userEditSave\" onClick={() => handleSaveClick()} >Save Changes</Button>\n        </Form>\n    )\n\n}","import { Route, Redirect } from \"react-router-dom\"\nimport { Login } from \"./auth/Login\"\nimport { Register } from \"./auth/Register\"\nimport { userStorageKey } from \"./auth/authSettings\"\nimport { RoutePage } from \"./routes/RoutePage\"\nimport { RouteProvider } from \"./routes/RouteProvider\"\nimport { TrafficProvider } from \"./routes/TrafficProvider\"\nimport { PathsProvider2 } from \"./paths/PathsProvider2\"\nimport { UserProvider } from \"./users/UserProvider\"\nimport { UserEditForm } from \"./users/UserEditForm\"\n\nexport const Checkpoint = () => {\n  return (\n    <>\n      <Route render={() => {\n        if (sessionStorage.getItem(userStorageKey)) {\n          // If the user is logged in\n          return (\n            <>\n            <UserProvider> \n              <RouteProvider>\n                <PathsProvider2>\n                  <TrafficProvider>\n                    <Route exact path=\"/\">\n                      <RoutePage />\n                    </Route>\n                    <Route exact path=\"/edit-profile\">\n                      <UserEditForm />\n                    </Route>\n                  </TrafficProvider>\n                </PathsProvider2>\n              </RouteProvider>\n            </UserProvider>\n            </>\n          )\n        } else {\n          return <Redirect to=\"/login\" />;\n        }\n      }} />\n\n      <Route path=\"/login\">\n        <Login />\n      </Route>\n      <Route path=\"/register\">\n        <Register />\n      </Route>\n    </>\n  )\n}\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Checkpoint } from './components/Checkpoint';\nimport reportWebVitals from './reportWebVitals';\nimport { BrowserRouter as Router } from \"react-router-dom\"\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Router>\n      <Checkpoint />\n    </Router>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}